# Analysis of the Housing Market in Illinois
## Video Demo: [https://youtu.be/VcH9MgnGsWI]
### Description:
About the data:
The housing market dataset used for this analysis was downloaded from Redfin Data Center (https://www.redfin.com/news/data-center/) on 21st March, 2024. The dataset is published by Redfin on a monthly basis and is computed as either a rolling 1,4 or 12-week window. I have not aggregated these cycles for each county as the cycles often overlap each other and since many of the details provided are averages, the correctness of the data would be compromised if the cycles were aggregated. Further, Redfin has grouped the data by metropolitan area and by county. As the original dataset is over 3GB in size, I have filtered for and extracted only the data pertaining to county-level information for the state of Illinois, which is the data subset used for my Python project.

About the code:
The get_input function creates a list of the county names within the provided dataset; as the dataset I'm using is the Illinois subset of the Redfin dataset, it will create a list of all the counties within Illinois, using the region name identifier column. As the aim of the analysis is to allow the user to check the metrics of the housing data for any Illinois county of their choosing, the function further checks whether the user input taken matches any item within the county list generated earlier. Match issues with respect to text case are handled by ensuring that the generated list, as well as the user input are both in the lower case. The user is further asked to choose the input interval for which they want to see the metrics, where the choice is between the 1, 4 or 12 week window cycles provided by Redfin. If the user inputs anything other than an Illinois county or a window cycle that is not available, the code will raise a ValueError and give appropriate details regarding what was wrong with the input.

The main function uses pandas to load the csv file into a dataframe. It also has a try-except block which ensures that the code repeatedly asks the user input for county and cycle length till both the conditions are met i.e. county must be in an Illinois county, and cycle length must be with 1, 4 or 12. When both the conditions are met, it calls the final function.

The subsetter function sets the chosen county name as a regex pattern, ignoring the case. Using this, the Illinois level dataset is filtered first for the chosen county and then filtered again for the chosen window cycle length. Essentially, a subset is created from the Illinois level dataset for the user's chosen county and interval. This subset is fed into the give_output function, which gives the averages of certain parameters at 2 levels i.e. county-level and Illinois-level, as well as the correlations between these. The rest of the function is devoted to plotting graphs based on the information available in the dataset along with the calculations made above. The graphs are labelled, formatted, and then saved as an image file for the user's convenience.

Perusing these graphs, it is possible to observe that the housing scenario in most counties has steadily turned in the sellers' favor over the last few years. Several factors support this assessment, most notably, the increase in percentage of homes sold above list price, the quick turnaround time evidenced by the decline in median days on market as well as the percentage of homes off the market within 1 week. Moreover, the average offer vis-a-vis the list price shows that the average offers were already above the listing price, but the average sale price has been even more than that in several counties (where the data is available). In some counties, it can be further observed that the inventory as well as the months of supply have been trending downwards, which means that the market is tightening and improves the sellers' bargaining power. In most cases, the total homes sold are moving in sync with total new listings, which strongly supports the sellers' market hypothesis, as almost every house that was listed has been sold. However, the buyers may note that there is tremendous seasonality in the housing market, and if we observe the graph for median sale price, the wave height (distance from peak to trough within a year) is usually much higher than the wave length (distance between two peaks or two troughs, i.e. roughly same period across years). This means that the buyers can take advantage of the lower prices during the "off-season" of the year, though the timing may coincide with a trough in the inventory cycle as well. Thus, we can conclude that most of the advantage is in the sellers' court, but there are a few beneficial points for buyers as well.

About the testing functions:
Four testing functions have been written to test each of the corresponding functions in the code apart from the main function. 2 test functions have been written for the last function, one testing for correct input and the other testing for incorrect ones.

For testing the get_input function, I had to use mocking because the function asks for 2 user inputs, and raises ValueError if certain conditions are not met. Assert could be used if only 1 user input was being taken. Accordingly, I designed 4 different test cases in which 3 were expected to raise the ValueError, while 1 tests the function with correct inputs and therefore should not give any error. For the cases raising the ValueError, there is 1 test case each checking for errors in user input with respect to incorrect county name and correct interval, and vice versa, and 1 test case with both the user inputs being incorrect. Incorrect county name is any county which is not present in the state of Illinois, while any interval other than 1,4 or 12 is considered incorrect. The patch decorator provides the mock inputs for each test case. The if-else condition inside the patch decorator checks for whether the mocked inputs should give rise to the error or not and handles them accordingly.

The subsetter function is supposed to build a subset from within the Redfin dataset of the entire Illinois data, based on the userinputs. Hence, all the values in the region_name and duration columns are expected to match the userinputs, i.e. neither should any non-Illinois county name be present in the subset, nor any Illinois county/ duration other than those that were inputted by the user. Accordingly, I have written test cases where it would pass only if all values match the userinput county and duration, and raise error if even a single value does not match the userinputs. For doing this, I have considered a mock subset using cook county with a 4 week duration and then tested the resulting subset. As the subsetter function prepares a dataframe with the filtered data, I have also checked that it returns empty dataframes when the userinputs are incorrect, though this should be handled by the get_input function.

The final function plots graphs based on the averaged values of certain columns from the subsetted data provided to the function. The errors for this function could only arise from errors in the input given to it, i.e. from the subsetter function which has already been checked above. Other than this, the rest of the function simply uses python's in-built computation functionality for averaging, and the matplotlib library's functionality of plotting graphs. As testing either of these is beyond the scope of this project, I have instead focused on checking whether the axes, title, and plot type are as coded. This is tested on a sample case using matplotcheck, with correct userinputs. I have also considered a case where the function does not plot anything as it does not receive any input from the subsetter function i.e. for incorrect userinputs , though this would already be handled by the get_input function.
